<?xml version="1.0" encoding="utf-8" ?> 
<DynLINQDoc xmlns="http://schemas.plainlogic.net/dynamiclinqdocs/2014">
  
  <Classes>
    <Class name="DynamicQueryable" namespace="System.Linq.Dynamic">
      <Description>Provides a set of **static** methods for querying data structures that implement `IQueryable`. It allows dynamic string based querying.  Very handy when, at compile time, you don't know the type of queries that will be generated, or when downstream components only return column names to sort and filter by.</Description>
      <Remarks></Remarks>

      <Methods>
        <Method name="Where&lt;TSource&gt;" isExtensionMethod="true" returnType="IQueryable&lt;TSource&gt;" hasParamsArgument="true">
          <Description>Filters a sequence of values based on a predicate.</Description>
          <ReturnDescription>A `IQueryable&lt;TSource&gt;` that contains elements from the input sequence that satisfy the condition specified by predicate.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable&lt;TSource&gt;" typeNamespace="System.Linq">
              <Description>A `IQueryable` to filter.</Description>
            </Argument>
            <Argument name="predicate" type="string" typeNamespace="System">
              <Description>An expression string to test each element for a condition.</Description>
            </Argument>
            <Argument name="args" type="object[]" typeNamespace="System">
              <Description>An object array that contains zero or more objects to insert into the predicate as parameters.  Similiar to the way `String.Format` formats strings.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following is an example of a *basic value* used in the `Where` string expression to filter a sequence.</HeaderRemarks>
              <ExampleCode>List&lt;string&gt; fruits =
    new List&lt;string> { "apple", "passionfruit", "banana", "mango", 
                        "orange", "blueberry", "grape", "strawberry" };

// Get all strings whose length is less than 6.
IEnumerable query = fruits.AsQueryable().Where("fruit.Length &lt; 6");

foreach (string fruit in query)
    Console.WriteLine(fruit);

/*
    This code produces the following output:

    apple
    mango
    grape
*/</ExampleCode>
            </Example>
            <Example>
              <HeaderRemarks>The following is an example of a *static argument value* used in the `Where` string expression to filter a sequence.</HeaderRemarks>
              <ExampleCode>IEnumerable&lt;string&gt; query = fruits.AsQueryable().Where("fruit.Length &lt; @0", 1);</ExampleCode>
            </Example>
            <Example>
              <HeaderRemarks>The following is an example of a *variable argument value* used in the `Where` string expression to filter a sequence.</HeaderRemarks>
              <ExampleCode>int someValue = 6;
 
IEnumerable&lt;string&gt; query = fruits.AsQueryable().Where("fruit.Length &lt; @0", someValue);</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="Where" isExtensionMethod="true" returnType="IQueryable" hasParamsArgument="true">
          <Description>Filters a sequence of values based on a predicate.</Description>
          <ReturnDescription>A `IQueryable` that contains elements from the input sequence that satisfy the condition specified by predicate.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` to filter.</Description>
            </Argument>
            <Argument name="predicate" type="string" typeNamespace="System">
              <Description>An expression string to test each element for a condition.</Description>
            </Argument>
            <Argument name="args" type="object[]" typeNamespace="System">
              <Description>An object array that contains zero or more objects to insert into the predicate as parameters.  Similiar to the way `String.Format` formats strings.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following is an example of a *basic value* used in the `Where` string expression to filter a sequence.</HeaderRemarks>
              <ExampleCode>List&lt;string&gt; fruits =
    new List&lt;string> { "apple", "passionfruit", "banana", "mango", 
                        "orange", "blueberry", "grape", "strawberry" };

// Get all strings whose length is less than 6.
IEnumerable query = fruits.AsQueryable().Where("fruit.Length &lt; 6");

foreach (string fruit in query)
    Console.WriteLine(fruit);

/*
    This code produces the following output:

    apple
    mango
    grape
*/</ExampleCode>
            </Example>
            <Example>
              <HeaderRemarks>The following is an example of a *static argument value* used in the `Where` string expression to filter a sequence.</HeaderRemarks>
              <ExampleCode>IEnumerable&lt;string&gt; query = fruits.AsQueryable().Where("fruit.Length &lt; @0", 1);</ExampleCode>
            </Example>
            <Example>
              <HeaderRemarks>The following is an example of a *variable argument value* used in the `Where` string expression to filter a sequence.</HeaderRemarks>
              <ExampleCode>int someValue = 6;
 
IEnumerable&lt;string&gt; query = fruits.AsQueryable().Where("fruit.Length &lt; @0", someValue);</ExampleCode>
            </Example>
          </Examples>
        </Method>
        
        <Method name="Select" isExtensionMethod="true" hasParamsArgument="true" returnType="IQueryable">
          <Description>Projects each element of a sequence into a new form.</Description>
          <ReturnDescription>An `IQueryable` whose elements are the result of invoking a projection string on each element of *source*.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A sequence of values to project.</Description>
            </Argument>
            <Argument name="selector" type="string" typeNamespace="System">
              <Description>A projection string expression to apply to each element.</Description>
            </Argument>
            <Argument name="args" type="object[]" typeNamespace="System">
              <Description>An object array that contains zero or more objects to insert into the predicate as parameters.  Similiar to the way `String.Format` formats strings.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following code example demonstrates how to use `Select` to project over a sequence of values, using the `it` keyword.</HeaderRemarks>
              <ExampleCode>List&lt;int&gt; range =
    new List&lt;int&gt; { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

// Project the square of each int value.
IEnumerable squares =
    range.AsQueryable().Select("it * it");

foreach (int num in squares)
    Console.WriteLine(num);

/*
    This code produces the following output:

    1
    4
    9
    16
    25
    36
    49
    64
    81
    100
*/</ExampleCode>
              <EquivalentCode>List&lt;int&gt; range =
    new List&lt;int&gt; { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

// Project the square of each int value.
IEnumerable&lt;int&gt; squares =
    range.AsQueryable().Select(x => x * x);

foreach (int num in squares)
    Console.WriteLine(num);

/*
    This code produces the following output:

    1
    4
    9
    16
    25
    36
    49
    64
    81
    100
*/</EquivalentCode>
            </Example>
            <Example>
              <HeaderRemarks>The following code example demonstrates how to use `Select` to project a single field and a group of fields over a sequence of values.</HeaderRemarks>
              <ExampleCode>class ExampleClass
{
    public string StringProperty1 { get; set; }
    public string StringProperty2 { get; set; }
}

//Select a single field
var singleField = qry.Select("StringProperty");
    
//Select a group of fields
var dynamicObject = qry.Select("new (StringProperty1, StringProperty2 as OtherStringPropertyName)");
              </ExampleCode>
            </Example>
            <Example>
              <HeaderRemarks>The following code example demonstrates how to use OfType inside a `Select`.</HeaderRemarks>
              <ExampleCode>
                class ExampleClass
                {
                public List&lt;Animal%gt; Animals
                }

                [DynamicLinqType]
                class Tiger : Animal { }

                var firstTigers = listOfExampleClass.Select("Animals.OfType(\"Tiger\").FirstOrDefault()");
              </ExampleCode>
              <EquivalentCode>
                var firstTigers = listOfExampleClass.Select(example => example.Animals.OfType&lt;Tiger&gt;().FirstOrDefault());
              </EquivalentCode>
            </Example>
            <Example>
              <HeaderRemarks>The following code example demonstrates how to use Skip, Take inside a `Select`.</HeaderRemarks>
              <ExampleCode>
                class ExampleClass
                {
                public List&lt;Animal%gt; Animals
                }

                var result = listOfExampleClass.Select("new { Animals.Skip(1).Take(1) AS SecondAnimal }");
              </ExampleCode>
              <EquivalentCode>
                var result = listOfExampleClass.Select(example => new { SecondAnimal = example.Animals.Skip(1).Take(1) });
              </EquivalentCode>
            </Example>
          </Examples>
        </Method>

        <Method name="SelectMany" isExtensionMethod="true" hasParamsArgument="true" returnType="IQueryable">
          <Description>Projects each element of a sequence to an `IQueryable` and combines the resulting sequences into one sequence.</Description>
          <ReturnDescription>An `IQueryable` whose elements are the result of invoking a one-to-many projection function on each element of the input sequence.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A sequence of values to project.</Description>
            </Argument>
            <Argument name="selector" type="string" typeNamespace="System">
              <Description>A projection string expression to apply to each element.</Description>
            </Argument>
            <Argument name="args" type="object[]" typeNamespace="System">
              <Description>An object array that contains zero or more objects to insert into the predicate as parameters.  Similiar to the way `String.Format` formats strings.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following code example demonstrates how to use `SelectMany` to perform a one-to-many projection over an array.</HeaderRemarks>
              <ExampleCode>class PetOwner
{
    public string Name { get; set; }
    public List&lt;String&gt; Pets { get; set; }
}

public static void SelectManyEx1()
{
    PetOwner[] petOwners =
        { new PetOwner { Name="Higa, Sidney",
              Pets = new List&lt;string&gt;{ "Scruffy", "Sam" } },
          new PetOwner { Name="Ashkenazi, Ronen",
              Pets = new List&lt;string&gt;{ "Walker", "Sugar" } },
          new PetOwner { Name="Price, Vernette",
              Pets = new List&lt;string&gt;{ "Scratches", "Diesel" } } };

    // Query using SelectMany().
    IEnumerable query1 =
        petOwners.AsQueryable().SelectMany("Pets");

    Console.WriteLine("Using SelectMany():");

    // Only one foreach loop is required to iterate through the
    // results because it is a one-dimensional collection.
    foreach (string pet in query1)
        Console.WriteLine(pet);

    // This code shows how to use Select() instead of SelectMany().
    IEnumerable query2 =
        petOwners.AsQueryable().Select("Pets");

    Console.WriteLine("\nUsing Select():");

    // Notice that two foreach loops are required to iterate through
    // the results because the query returns a collection of arrays.
    foreach (IEnumerable petList in query2)
    {
        foreach (string pet in petList)
        {
            Console.WriteLine(pet);
        }
        Console.WriteLine();
    }
}

/*
    This code produces the following output:

    Using SelectMany():
    Scruffy
    Sam
    Walker
    Sugar
    Scratches
    Diesel

    Using Select():
    Scruffy
    Sam

    Walker
    Sugar

    Scratches
    Diesel
*/</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="OrderBy&lt;TSource&gt;" isExtensionMethod="true" hasParamsArgument="true" returnType="IQueryable&lt;TSource&gt;">
          <Description>Sorts the elements of a sequence in ascending order according to a key.</Description>
          <ReturnDescription>A `IQueryable&lt;T&gt;` whose elements are sorted according to the specified **ordering**.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable&lt;TSource&gt;" typeNamespace="System.Linq">
              <Description>A sequence of values to order.</Description>
            </Argument>
            <Argument name="ordering" type="string" typeNamespace="System">
              <Description>An expression string to indicate values to order by.</Description>
            </Argument>
            <Argument name="args" type="object[]" typeNamespace="System">
              <Description>An object array that contains zero or more objects to insert into the predicate as parameters.  Similiar to the way `String.Format` formats strings.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <ExampleCode>var result = list.OrderBy("NumberProperty, StringProperty DESC");</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="OrderBy" isExtensionMethod="true" hasParamsArgument="true" returnType="IQueryable">
          <Description>Sorts the elements of a sequence in ascending order according to a key.</Description>
          <ReturnDescription>A `IQueryable` whose elements are sorted according to the specified **ordering**.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A sequence of values to order.</Description>
            </Argument>
            <Argument name="ordering" type="string" typeNamespace="System">
              <Description>An expression string to indicate values to order by.</Description>
            </Argument>
            <Argument name="args" type="object[]" typeNamespace="System">
              <Description>An object array that contains zero or more objects to insert into the predicate as parameters.  Similiar to the way `String.Format` formats strings.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <ExampleCode>var result = list.OrderBy("NumberProperty, StringProperty DESC");</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="GroupBy" isExtensionMethod="true" returnType="IQueryable">
          <Description>Groups the elements of a sequence according to a specified key string function and creates a result value from each group and its key.</Description>
          <ReturnDescription>A `IQueryable` where each element represents a projection over a group and its key.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` whose elements to group.</Description>
            </Argument>
            <Argument name="keySelector" type="string" typeNamespace="System">
              <Description>A string expression to specify the key for each element.</Description>
            </Argument>
            <Argument name="resultSelector" type="string" typeNamespace="System">
              <Description>A string expression to specify a result value from each group.</Description>
            </Argument>
            <Argument name="args" type="object[]" typeNamespace="System">
              <Description>An object array that contains zero or more objects to insert into the predicate as parameters.  Similiar to the way String.Format formats strings.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following is an example of a simple `GroupBy`.</HeaderRemarks>
              <ExampleCode>var groupResult = qry.GroupBy("NumberPropertyAsKey", "StringProperty");</ExampleCode>
            </Example>
            <Example>
              <HeaderRemarks>The following is an example of a `GroupBy` using multiple key fields and multiple grouped fields.</HeaderRemarks>
              <ExampleCode>var groupResult = qry.GroupBy("new (NumberPropertyAsKey, StringPropertyAsKey)", "new (StringProperty1, StringProperty2)");</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="GroupBy" isExtensionMethod="true" returnType="IQueryable">
          <Description>Groups the elements of a sequence according to a specified key string function and creates a result value from each group and its key.</Description>
          <ReturnDescription>A `IQueryable` where each element represents a projection over a group and its key.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` whose elements to group.</Description>
            </Argument>
            <Argument name="keySelector" type="string" typeNamespace="System">
              <Description>A string expression to specify the key for each element.</Description>
            </Argument>
            <Argument name="resultSelector" type="string" typeNamespace="System">
              <Description>A string expression to specify a result value from each group.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following is an example of a simple `GroupBy`.</HeaderRemarks>
              <ExampleCode>var groupResult = qry.GroupBy("NumberPropertyAsKey", "StringProperty");</ExampleCode>
            </Example>
            <Example>
              <HeaderRemarks>The following is an example of a `GroupBy` using multiple key fields and multiple grouped fields.</HeaderRemarks>
              <ExampleCode>var groupResult = qry.GroupBy("new (NumberPropertyAsKey, StringPropertyAsKey)", "new (StringProperty1, StringProperty2)");</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="GroupBy" isExtensionMethod="true" returnType="IQueryable">
          <Description>Groups the elements of a sequence according to a specified key string function and creates a result value from each group and its key.</Description>
          <ReturnDescription>A `IQueryable` where each element represents a projection over a group and its key.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` whose elements to group.</Description>
            </Argument>
            <Argument name="keySelector" type="string" typeNamespace="System">
              <Description>A string expression to specify the key for each element.</Description>
            </Argument>
            <Argument name="args" type="object[]" typeNamespace="System">
              <Description>An object array that contains zero or more objects to insert into the predicate as parameters.  Similiar to the way String.Format formats strings.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following is an example of a simple `GroupBy`.</HeaderRemarks>
              <ExampleCode>var groupResult = qry.GroupBy("NumberPropertyAsKey", "StringProperty");</ExampleCode>
            </Example>
            <Example>
              <HeaderRemarks>The following is an example of a `GroupBy` using multiple key fields and multiple grouped fields.</HeaderRemarks>
              <ExampleCode>var groupResult = qry.GroupBy("new (NumberPropertyAsKey, StringPropertyAsKey)", "new (StringProperty1, StringProperty2)");</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="GroupBy" isExtensionMethod="true" returnType="IQueryable">
          <Description>Groups the elements of a sequence according to a specified key string function and creates a result value from each group and its key.</Description>
          <ReturnDescription>A `IQueryable` where each element represents a projection over a group and its key.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` whose elements to group.</Description>
            </Argument>
            <Argument name="keySelector" type="string" typeNamespace="System">
              <Description>A string expression to specify the key for each element.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following is an example of a simple `GroupBy`.</HeaderRemarks>
              <ExampleCode>var groupResult = qry.GroupBy("NumberPropertyAsKey", "StringProperty");</ExampleCode>
            </Example>
            <Example>
              <HeaderRemarks>The following is an example of a `GroupBy` using multiple key fields and multiple grouped fields.</HeaderRemarks>
              <ExampleCode>var groupResult = qry.GroupBy("new (NumberPropertyAsKey, StringPropertyAsKey)", "new (StringProperty1, StringProperty2)");</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="GroupByMany&lt;TElement&gt;" isExtensionMethod="true" hasParamsArgument="true" returnType="IEnumerable&lt;GroupResult&gt;">
          <Description>Groups the elements of a sequence according to multiple specified key string functions and creates a result value from each group (and subgroups) and its key.</Description>
          <ReturnDescription>A `IEnumerable&lt;GroupResult&gt;` where each element represents a projection over a group, its key, and its subgroups.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IEnumerable&lt;TElement&gt;" typeNamespace="System.Collections.Generic">
              <Description>A `IEnumerable&lt;TElement&gt;` whose elements to group.</Description>
            </Argument>
            <Argument name="keySelectors" type="string[]" typeNamespace="System">
              <Description>`string` expressions to specify the keys for each element.</Description>
            </Argument>
          </Arguments>
        </Method>

        <Method name="GroupByMany&lt;TElement&gt;" isExtensionMethod="true" hasParamsArgument="true" returnType="IEnumerable&lt;GroupResult&gt;">
          <Description>Groups the elements of a sequence according to multiple specified key string functions and creates a result value from each group (and subgroups) and its key.</Description>
          <ReturnDescription>A `IEnumerable&lt;GroupResult&gt;` where each element represents a projection over a group, its key, and its subgroups.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IEnumerable&lt;TElement&gt;" typeNamespace="System.Collections.Generic">
              <Description>A `IEnumerable&lt;TElement&gt;` whose elements to group.</Description>
            </Argument>
            <Argument name="keySelectors" type="Func&lt;TElement,object&gt;[]" typeNamespace="System">
              <Description>Lambda expressions to specify the keys for each element.</Description>
            </Argument>
          </Arguments>
        </Method>

        <Method name="Join" returnType="IQueryable" isExtensionMethod="true" hasParamsArgument="true">
          <Description>Correlates the elements of two sequences based on matching keys. The default equality comparer is used to compare keys.</Description>
          <ReturnDescription>An `IQueryable` obtained by performing an inner join on two sequences.</ReturnDescription>
          <Arguments>
            <Argument name="outer" type="IQueryable" typeNamespace="System.Linq">
              <Description>The first sequence to join.</Description>
            </Argument>
            <Argument name="inner" type="IEnumerable" typeNamespace="System.Collections">
              <Description>The sequence to join to the first sequence.</Description>
            </Argument>
            <Argument name="outerKeySelector" type="string" typeNamespace="System">
              <Description>A dynamic function to extract the join key from each element of the first sequence.</Description>
            </Argument>
            <Argument name="innerKeySelector" type="string" typeNamespace="System">
              <Description>A dynamic function to extract the join key from each element of the second sequence.</Description>
            </Argument>
            <Argument name="resultSelector" type="string" typeNamespace="System">
              <Description>A dynamic function to create a result element from two matching elements.</Description>
            </Argument>
            <Argument name="args" type="object[]" typeNamespace="System">
              <Description>An object array that contains zero or more objects to insert into the predicates as parameters.  Similiar to the way String.Format formats strings.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following code example demonstrates how to use `Join` to perform an inner join of two sequences based on a common key using Dynamic LINQ.</HeaderRemarks>
              <ExampleCode>class Person
{
    public string Name { get; set; }
}

class Pet
{
    public string Name { get; set; }
    public Person Owner { get; set; }
}

public static void JoinEx1()
{
    Person magnus = new Person { Name = "Hedlund, Magnus" };
    Person terry = new Person { Name = "Adams, Terry" };
    Person charlotte = new Person { Name = "Weiss, Charlotte" };

    Pet barley = new Pet { Name = "Barley", Owner = terry };
    Pet boots = new Pet { Name = "Boots", Owner = terry };
    Pet whiskers = new Pet { Name = "Whiskers", Owner = charlotte };
    Pet daisy = new Pet { Name = "Daisy", Owner = magnus };

    List&lt;Person&gt; people = new List&lt;Person&gt; { magnus, terry, charlotte };
    List&lt;Pet&gt; pets = new List&lt;Pet&gt; { barley, boots, whiskers, daisy };

    // Join the list of Person objects and the list of Pet objects 
    // to create a list of person-pet pairs where each element is 
    // an anonymous type that contains the name of pet and the name
    // of the person that owns the pet.
    var query = people.AsQueryable().Join(
        pets,
        "it",
        "Owner",
        "new(outer.Name as OwnerName, inner.Name as Pet)";
      

    foreach (var obj in query)
    {
        Console.WriteLine(
            "{0} - {1}",
            obj.OwnerName,
            obj.Pet);
    }
}

/*
    This code produces the following output:

    Hedlund, Magnus - Daisy
    Adams, Terry - Barley
    Adams, Terry - Boots
    Weiss, Charlotte - Whiskers
*/</ExampleCode>
              <EquivalentCode>class Person
{
    public string Name { get; set; }
}

class Pet
{
    public string Name { get; set; }
    public Person Owner { get; set; }
}

public static void JoinEx1()
{
    Person magnus = new Person { Name = "Hedlund, Magnus" };
    Person terry = new Person { Name = "Adams, Terry" };
    Person charlotte = new Person { Name = "Weiss, Charlotte" };

    Pet barley = new Pet { Name = "Barley", Owner = terry };
    Pet boots = new Pet { Name = "Boots", Owner = terry };
    Pet whiskers = new Pet { Name = "Whiskers", Owner = charlotte };
    Pet daisy = new Pet { Name = "Daisy", Owner = magnus };

    List&lt;Person&gt; people = new List&lt;Person&gt; { magnus, terry, charlotte };
    List&lt;Pet&gt; pets = new List&lt;Pet&gt; { barley, boots, whiskers, daisy };

    // Join the list of Person objects and the list of Pet objects 
    // to create a list of person-pet pairs where each element is 
    // an anonymous type that contains the name of pet and the name
    // of the person that owns the pet.
    var query = people.AsQueryable().Join(
        pets,
        person => person,
        pet => pet.Owner,
        (person, pet) =>
            new { OwnerName = person.Name, Pet = pet.Name });

    foreach (var obj in query)
    {
        Console.WriteLine(
            "{0} - {1}",
            obj.OwnerName,
            obj.Pet);
    }
}

/*
    This code produces the following output:

    Hedlund, Magnus - Daisy
    Adams, Terry - Barley
    Adams, Terry - Boots
    Weiss, Charlotte - Whiskers
*/</EquivalentCode>
            </Example>
          </Examples>
        </Method>
         
        <Method name="Join&lt;TElement&gt;" returnType="IQueryable&lt;TElement&gt;" isExtensionMethod="true" hasParamsArgument="true">
          <Description>Correlates the elements of two sequences based on matching keys. The default equality comparer is used to compare keys.</Description>
          <Remarks>This `Join` overload only works on elements where both sequences and the resulting element match.</Remarks>
          <ReturnDescription>An `IQueryable&lt;TElement&gt;` obtained by performing an inner join on two sequences.</ReturnDescription>
          <Arguments>
            <Argument name="outer" type="IQueryable&lt;TElement&gt;" typeNamespace="System.Linq">
              <Description>The first sequence to join.</Description>
            </Argument>
            <Argument name="inner" type="IEnumerable&lt;TElement&gt;" typeNamespace="System.Collections">
              <Description>The sequence to join to the first sequence.</Description>
            </Argument>
            <Argument name="outerKeySelector" type="string" typeNamespace="System">
              <Description>A dynamic function to extract the join key from each element of the first sequence.</Description>
            </Argument>
            <Argument name="innerKeySelector" type="string" typeNamespace="System">
              <Description>A dynamic function to extract the join key from each element of the second sequence.</Description>
            </Argument>
            <Argument name="resultSelector" type="string" typeNamespace="System">
              <Description>A dynamic function to create a result element from two matching elements.</Description>
            </Argument>
            <Argument name="args" type="object[]" typeNamespace="System">
              <Description>An object array that contains zero or more objects to insert into the predicates as parameters.  Similiar to the way String.Format formats strings.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following code example demonstrates how to use `Join` to perform an inner join of two sequences based on a common key using Dynamic LINQ.</HeaderRemarks>
              <ExampleCode>class Person
{
    public string Name { get; set; }
}

class Pet
{
    public string Name { get; set; }
    public Person Owner { get; set; }
}

public static void JoinEx1()
{
    Person magnus = new Person { Name = "Hedlund, Magnus" };
    Person terry = new Person { Name = "Adams, Terry" };
    Person charlotte = new Person { Name = "Weiss, Charlotte" };

    Pet barley = new Pet { Name = "Barley", Owner = terry };
    Pet boots = new Pet { Name = "Boots", Owner = terry };
    Pet whiskers = new Pet { Name = "Whiskers", Owner = charlotte };
    Pet daisy = new Pet { Name = "Daisy", Owner = magnus };

    List&lt;Person&gt; people = new List&lt;Person&gt; { magnus, terry, charlotte };
    List&lt;Pet&gt; pets = new List&lt;Pet&gt; { barley, boots, whiskers, daisy };

    // Join the list of Person objects and the list of Pet objects 
    // to create a list of person-pet pairs where each element is 
    // an anonymous type that contains the name of pet and the name
    // of the person that owns the pet.
    var query = people.AsQueryable().Join(
        pets,
        "it",
        "Owner",
        "new(outer.Name as OwnerName, inner.Name as Pet)";
      

    foreach (var obj in query)
    {
        Console.WriteLine(
            "{0} - {1}",
            obj.OwnerName,
            obj.Pet);
    }
}

/*
    This code produces the following output:

    Hedlund, Magnus - Daisy
    Adams, Terry - Barley
    Adams, Terry - Boots
    Weiss, Charlotte - Whiskers
*/</ExampleCode>
              <EquivalentCode>class Person
{
    public string Name { get; set; }
}

class Pet
{
    public string Name { get; set; }
    public Person Owner { get; set; }
}

public static void JoinEx1()
{
    Person magnus = new Person { Name = "Hedlund, Magnus" };
    Person terry = new Person { Name = "Adams, Terry" };
    Person charlotte = new Person { Name = "Weiss, Charlotte" };

    Pet barley = new Pet { Name = "Barley", Owner = terry };
    Pet boots = new Pet { Name = "Boots", Owner = terry };
    Pet whiskers = new Pet { Name = "Whiskers", Owner = charlotte };
    Pet daisy = new Pet { Name = "Daisy", Owner = magnus };

    List&lt;Person&gt; people = new List&lt;Person&gt; { magnus, terry, charlotte };
    List&lt;Pet&gt; pets = new List&lt;Pet&gt; { barley, boots, whiskers, daisy };

    // Join the list of Person objects and the list of Pet objects 
    // to create a list of person-pet pairs where each element is 
    // an anonymous type that contains the name of pet and the name
    // of the person that owns the pet.
    var query = people.AsQueryable().Join(
        pets,
        person => person,
        pet => pet.Owner,
        (person, pet) =>
            new { OwnerName = person.Name, Pet = pet.Name });

    foreach (var obj in query)
    {
        Console.WriteLine(
            "{0} - {1}",
            obj.OwnerName,
            obj.Pet);
    }
}

/*
    This code produces the following output:

    Hedlund, Magnus - Daisy
    Adams, Terry - Barley
    Adams, Terry - Boots
    Weiss, Charlotte - Whiskers
*/</EquivalentCode>
            </Example>
          </Examples>
        </Method>
      </Methods>
    </Class>
  </Classes>
</DynLINQDoc>